<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>deduct</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@300;400;600;700&display=swap');
        
        body {
            font-family: 'Source Sans Pro', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #FFF6EB;
        }

        .game-container {
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 12px #D7C2B0;
        }

        h1 {
            color: #0C4F4E;
            margin-bottom: 20px;
            font-weight: 100;
        }

        .instructions {
            color: #1f1d1d;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 300;
        }

        .grid-container {
            display: inline-block;
            position: relative;
        }

        .grid-wrapper {
            display: grid;
            grid-template-columns: 60px repeat(7, 50px) 60px;
            grid-template-rows: 40px repeat(7, 50px) 40px;
            gap: 0;
            background-color: white;
        }

        .grid {
            grid-column: 2 / 9;
            grid-row: 2 / 9;
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(7, 50px);
            gap: 1px;
            background-color: black;
            outline: 3px solid black;
            outline-offset: -1px;
        }

        .cell {
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            color: #1f1d1d;
        }

        .cell:hover {
            background-color: #FFF6EB;
        }

        .cell.deleted {
            background-color: #9D442A;
            color: #FFF6EB;
        }
      
       .cell.confirmed {
            background-color: #9EB5A3;
            color: #0C4F4E;
            font-weight: 700;
            border: 2px solid #0C4F4E;
            box-sizing: border-box;
        }

        .cell.confirmed:hover {
            background-color: #8AA690;
        }

        .targets {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 20px;
        }

        .row-targets, .col-targets {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .row-target {
            grid-column: 1;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            color: #1f1d1d;
        }

        .col-target {
            grid-row: 1;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            color: #1f1d1d;
        }

        .row-current {
            grid-column: 9;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 400;
            font-size: 12px;
            color: #1f1d1d;
        }

        .col-current {
            grid-row: 9;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 400;
            font-size: 12px;
            color: #1f1d1d;
        }

        .corner-cell {
            grid-column: 1;
            grid-row: 1;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #9D442A;
            font-weight: 600;
        }

        .corner-current {
            grid-column: 9;
            grid-row: 9;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #9D442A;
            font-weight: 400;
        }
      
        .corner-top-right {
            grid-column: 9;
            grid-row: 1;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #0C4F4E;
         }

        .corner-bottom-left {
            grid-column: 1;
            grid-row: 9;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #FFF6EB;
        }

        .target.complete, .row-target.complete, .col-target.complete, .row-current.complete, .col-current.complete {
            background-color: #0C4F4E !important;
            color: #FFF6EB !important;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Source Sans Pro', sans-serif;
            font-weight: 300;
            border: none;
            border-radius: 8px;
            background-color: #0C4F4E;
            color: #FFF6EB;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #9EB5A3;
            transform: translateY(-1px);
        }

        .status {
            margin-top: 15px;
            font-size: 18px;
            font-weight: 600;
            min-height: 25px;
            color: #1f1d1d;
        }
      
      .timer {
            margin: 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #0C4F4E;
            background-color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid #D7C2B0;
            display: inline-block;
            min-width: 80px;
        }

        .timer.completed {
            background-color: #9D442A;
            color: #FFF6EB;
            border-color: #9D442A;
        }

        .status.win {
            color: #0C4F4E;
        }

        .puzzle-info {
            margin-bottom: 10px;
            font-size: 12px;
            color: #0C4F4E;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>deduct</h1>
        <div class="instructions">
            Select boxes to delete the numbers. Click once to confirm a cell should stay and twice to delete. <br/> Make each row and column sum to the target values!
        </div>
      
      <div class="timer" id="gameTimer">00:00</div>
      <div class="puzzle-info" id="puzzleInfo">Loading puzzle...</div>
      
      <br/>
              
        <div class="grid-container">
            <div class="grid-wrapper" id="gridWrapper">
                <div class="grid" id="gameGrid"></div>
            </div>
        </div>
        
        <div class="targets" style="display: none;">
            <div>
                <h3>Row Targets</h3>
                <div class="row-targets" id="rowTargets"></div>
            </div>
            <div>
                <h3>Column Targets</h3>
                <div class="col-targets" id="colTargets"></div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="resetPuzzle()">Reset</button>
            <button onclick="newPuzzle()">New Puzzle</button>
        </div>
        
        <div class="status" id="gameStatus"></div>
    </div>

    <script>
        // Game state
        let gameState = {
            grid: [],
            deleted: [],
            confirmed: [],
            rowTargets: [],
            colTargets: [],
            size: 7,
            startTime: null,
            timerInterval: null,
            gameCompleted: false,
            currentPuzzle: null,
            solutionMask: null
        };

        // New puzzle generator class
        class SumpleteGenerator {
            constructor(size = 7) {
                this.size = size;
                this.minValue = 1;
                this.maxValue = 9;
                this.maxAttempts = 1000;
            }

            generate() {
                for (let attempt = 0; attempt < this.maxAttempts; attempt++) {
                    const puzzle = this.attemptGeneration();
                    if (puzzle) return puzzle;
                }
                console.log("Could not generate valid puzzle, using fallback");
                return this.generateFallbackPuzzle();
            }

            attemptGeneration() {
                // Step 1: Create a solution mask (which cells to keep)
                const solutionMask = this.createValidSolutionMask();
                if (!solutionMask) return null;

                // Step 2: Fill the grid with random values
                const grid = this.createGrid();

                // Step 3: Calculate targets based on solution
                const targets = this.calculateTargets(grid, solutionMask);

                // Step 4: Validate the puzzle meets all criteria
                if (this.validatePuzzle(grid, solutionMask, targets)) {
                    return { 
                        grid, 
                        solutionMask, 
                        rowTargets: targets.row, 
                        colTargets: targets.col 
                    };
                }

                return null;
            }

            createValidSolutionMask() {
                const mask = Array(this.size).fill().map(() => Array(this.size).fill(false));
                
                // Ensure each row and column has 1-6 cells kept (so 1-6 deleted)
                for (let i = 0; i < this.size; i++) {
                    // Randomly decide how many cells to keep in this row (1-6)
                    const rowKeepCount = 1 + Math.floor(Math.random() * 6);
                    const rowIndices = this.shuffleArray([...Array(this.size).keys()]);
                    for (let j = 0; j < rowKeepCount; j++) {
                        mask[i][rowIndices[j]] = true;
                    }
                }

                // Verify columns also have 1-6 cells kept
                for (let j = 0; j < this.size; j++) {
                    const colCount = mask.map(row => row[j]).filter(x => x).length;
                    if (colCount === 0 || colCount === this.size) {
                        // Fix column by toggling some cells
                        if (colCount === 0) {
                            // Add at least one cell
                            const row = Math.floor(Math.random() * this.size);
                            mask[row][j] = true;
                        } else {
                            // Remove at least one cell
                            const keptRows = [];
                            for (let i = 0; i < this.size; i++) {
                                if (mask[i][j]) keptRows.push(i);
                            }
                            const toRemove = keptRows[Math.floor(Math.random() * keptRows.length)];
                            mask[toRemove][j] = false;
                        }
                    }
                }

                return mask;
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.size; i++) {
                    const row = [];
                    const usedCounts = {};
                    
                    for (let j = 0; j < this.size; j++) {
                        let value;
                        let attempts = 0;
                        
                        do {
                            value = this.minValue + Math.floor(Math.random() * (this.maxValue - this.minValue + 1));
                            attempts++;
                        } while (usedCounts[value] >= 3 && attempts < 50);
                        
                        usedCounts[value] = (usedCounts[value] || 0) + 1;
                        row.push(value);
                    }
                    grid.push(row);
                }

                // Check columns for duplicates
                for (let j = 0; j < this.size; j++) {
                    const colCounts = {};
                    for (let i = 0; i < this.size; i++) {
                        colCounts[grid[i][j]] = (colCounts[grid[i][j]] || 0) + 1;
                    }
                    
                    // Fix any column with more than 3 of same value
                    for (let value in colCounts) {
                        if (colCounts[value] > 3) {
                            const positions = [];
                            for (let i = 0; i < this.size; i++) {
                                if (grid[i][j] === parseInt(value)) positions.push(i);
                            }
                            
                            // Change excess occurrences
                            const toChange = positions.slice(3);
                            for (let pos of toChange) {
                                let newValue;
                                do {
                                    newValue = this.minValue + Math.floor(Math.random() * (this.maxValue - this.minValue + 1));
                                } while (colCounts[newValue] >= 3);
                                
                                colCounts[grid[pos][j]]--;
                                grid[pos][j] = newValue;
                                colCounts[newValue] = (colCounts[newValue] || 0) + 1;
                            }
                        }
                    }
                }

                return grid;
            }

            calculateTargets(grid, solutionMask) {
                const rowTargets = [];
                const colTargets = [];

                for (let i = 0; i < this.size; i++) {
                    let rowSum = 0;
                    for (let j = 0; j < this.size; j++) {
                        if (solutionMask[i][j]) {
                            rowSum += grid[i][j];
                        }
                    }
                    rowTargets.push(rowSum);
                }

                for (let j = 0; j < this.size; j++) {
                    let colSum = 0;
                    for (let i = 0; i < this.size; i++) {
                        if (solutionMask[i][j]) {
                            colSum += grid[i][j];
                        }
                    }
                    colTargets.push(colSum);
                }

                return { row: rowTargets, col: colTargets };
            }

            validatePuzzle(grid, solutionMask, targets) {
                // Check that no row already sums to target
                for (let i = 0; i < this.size; i++) {
                    const fullRowSum = grid[i].reduce((a, b) => a + b, 0);
                    if (fullRowSum === targets.row[i]) return false;
                    
                    // Check deletion count (1-6 cells deleted)
                    const deletedCount = solutionMask[i].filter(x => !x).length;
                    if (deletedCount < 1 || deletedCount > 6) return false;
                }

                // Check that no column already sums to target
                for (let j = 0; j < this.size; j++) {
                    let fullColSum = 0;
                    let deletedCount = 0;
                    
                    for (let i = 0; i < this.size; i++) {
                        fullColSum += grid[i][j];
                        if (!solutionMask[i][j]) deletedCount++;
                    }
                    
                    if (fullColSum === targets.col[j]) return false;
                    if (deletedCount < 1 || deletedCount > 6) return false;
                }

                return true;
            }

            shuffleArray(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            generateFallbackPuzzle() {
                // Simple fallback puzzle that's guaranteed to be valid
                return {
                    grid: [
                        [3, 7, 2, 8, 1, 6, 4],
                        [5, 1, 9, 3, 7, 2, 8],
                        [2, 8, 4, 6, 3, 1, 7],
                        [7, 3, 6, 1, 9, 4, 2],
                        [1, 5, 8, 7, 2, 9, 3],
                        [9, 2, 1, 4, 8, 3, 6],
                        [4, 6, 3, 2, 5, 7, 1]
                    ],
                    rowTargets: [15, 20, 18, 16, 22, 19, 14],
                    colTargets: [17, 21, 19, 15, 18, 16, 20],
                    solutionMask: Array(7).fill().map(() => Array(7).fill(true))
                };
            }
        }

        function startTimer() {
            gameState.startTime = Date.now();
            gameState.gameCompleted = false;
            
            gameState.timerInterval = setInterval(() => {
                if (!gameState.gameCompleted) {
                    updateTimerDisplay();
                }
            }, 1000);
        }

        function stopTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            gameState.gameCompleted = true;
        }
      
        function updateTimerDisplay() {
            if (!gameState.startTime) return;
            
            const elapsed = Date.now() - gameState.startTime;
            const seconds = Math.floor(elapsed / 1000);
            const minutes = Math.floor(seconds / 60);
            const displaySeconds = seconds % 60;
            
            const timerElement = document.getElementById('gameTimer');
            timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
        }
      
        function getElapsedTime() {
            if (!gameState.startTime) return 0;
            return Math.floor((Date.now() - gameState.startTime) / 1000);
        }
      
        function initializeGame(puzzle = null) {
            if (!gameState.startTime) {
                startTimer();
            }
            
            // Use provided puzzle or generate a new one
            if (puzzle) {
                gameState.currentPuzzle = puzzle;
            } else if (!gameState.currentPuzzle) {
                console.log("Generating new puzzle...");
                const generator = new SumpleteGenerator();
                gameState.currentPuzzle = generator.generate();
            }
         
            // Copy puzzle data to game state
            gameState.grid = gameState.currentPuzzle.grid.map(row => [...row]);
            gameState.rowTargets = [...gameState.currentPuzzle.rowTargets];
            gameState.colTargets = [...gameState.currentPuzzle.colTargets];
            gameState.solutionMask = gameState.currentPuzzle.solutionMask;
            
            // Initialize deleted and confirmed states
            gameState.deleted = Array(7).fill().map(() => Array(7).fill(false));
            gameState.confirmed = Array(7).fill().map(() => Array(7).fill(false));

            // Update puzzle info
            updatePuzzleInfo();
            
            renderGrid();
            updateStatus();
        }

        function updatePuzzleInfo() {
            const info = document.getElementById('puzzleInfo');
            info.textContent = 'Generated puzzle';
        }

        function renderGrid() {
            const grid = document.getElementById('gameGrid');
            const gridWrapper = document.getElementById('gridWrapper');
            grid.innerHTML = '';
            
            // Remove old target and current elements
            gridWrapper.querySelectorAll('.row-target, .col-target, .row-current, .col-current').forEach(el => el.remove());
            
            // Add column targets (top)
            for (let col = 0; col < 7; col++) {
                const colTarget = document.createElement('div');
                colTarget.className = 'col-target';
                colTarget.style.gridColumn = col + 2;
                colTarget.style.gridRow = 1;
                
                const currentSum = getCurrentColSum(col);
                const targetSum = gameState.colTargets[col];
                colTarget.textContent = `${targetSum}`;
                
                if (currentSum === targetSum) {
                    colTarget.classList.add('complete');
                }
                
                gridWrapper.appendChild(colTarget);
            }
            
            // Add column currents (bottom) - showing difference from target
            for (let col = 0; col < 7; col++) {
                const colCurrent = document.createElement('div');
                colCurrent.className = 'col-current';
                colCurrent.style.gridColumn = col + 2;
                colCurrent.style.gridRow = 9;
                
                const currentSum = getCurrentColSum(col);
                const targetSum = gameState.colTargets[col];
                const difference = currentSum - targetSum;
                
                if (difference === 0) {
                    colCurrent.textContent = `âœ“`;
                    colCurrent.classList.add('complete');
                } else if (difference > 0) {
                    colCurrent.textContent = `-${difference}`;
                } else {
                    colCurrent.textContent = `+${Math.abs(difference)}`;
                }
                
                gridWrapper.appendChild(colCurrent);
            }
            
            // Add row targets (left)
            for (let row = 0; row < 7; row++) {
                const rowTarget = document.createElement('div');
                rowTarget.className = 'row-target';
                rowTarget.style.gridColumn = 1;
                rowTarget.style.gridRow = row + 2;
                
                const currentSum = getCurrentRowSum(row);
                const targetSum = gameState.rowTargets[row];
                rowTarget.textContent = `${targetSum}`;
                
                if (currentSum === targetSum) {
                    rowTarget.classList.add('complete');
                }
                
                gridWrapper.appendChild(rowTarget);
            }
            
            // Add row currents (right) - showing difference from target
            for (let row = 0; row < 7; row++) {
                const rowCurrent = document.createElement('div');
                rowCurrent.className = 'row-current';
                rowCurrent.style.gridColumn = 9;
                rowCurrent.style.gridRow = row + 2;
                
                const currentSum = getCurrentRowSum(row);
                const targetSum = gameState.rowTargets[row];
                const difference = currentSum - targetSum;
                
                if (difference === 0) {
                    rowCurrent.textContent = `âœ“`;
                    rowCurrent.classList.add('complete');
                } else if (difference > 0) {
                    rowCurrent.textContent = `-${difference}`;
                } else {
                    rowCurrent.textContent = `+${Math.abs(difference)}`;
                }
                
                gridWrapper.appendChild(rowCurrent);
            }
            
            // Add grid cells
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = gameState.grid[row][col];
                    cell.onclick = () => toggleCell(row, col);
                    
                    // Apply the appropriate state class
                    if (gameState.deleted[row][col]) {
                        cell.classList.add('deleted');
                    } else if (gameState.confirmed[row][col]) {
                        cell.classList.add('confirmed');
                    }

                    grid.appendChild(cell);
                }
            }
        }

        function toggleCell(row, col) {
            // Start timer on first move if not already started
            if (!gameState.startTime) {
                startTimer();
            }
          
            // Cycle through three states: normal -> confirmed -> deleted -> normal
            if (!gameState.confirmed[row][col] && !gameState.deleted[row][col]) {
                // Normal -> Confirmed
                gameState.confirmed[row][col] = true;
            } else if (gameState.confirmed[row][col]) {
                // Confirmed -> Deleted
                gameState.confirmed[row][col] = false;
                gameState.deleted[row][col] = true;
            } else {
                // Deleted -> Normal
                gameState.deleted[row][col] = false;
            }
            
            renderGrid();
            updateStatus();
        }

        function getCurrentRowSum(row) {
            let sum = 0;
            for (let col = 0; col < 7; col++) {
                if (!gameState.deleted[row][col]) {
                    sum += gameState.grid[row][col];
                }
            }
            return sum;
        }

        function getCurrentColSum(col) {
            let sum = 0;
            for (let row = 0; row < 7; row++) {
                if (!gameState.deleted[row][col]) {
                    sum += gameState.grid[row][col];
                }
            }
            return sum;
        }

        function checkWin() {
            for (let i = 0; i < 7; i++) {
                if (getCurrentRowSum(i) !== gameState.rowTargets[i]) return false;
                if (getCurrentColSum(i) !== gameState.colTargets[i]) return false;
            }
            return true;
        }

        function updateStatus() {
            const status = document.getElementById('gameStatus');
            const timer = document.getElementById('gameTimer');
          
            if (checkWin()) {
                const finalTime = getElapsedTime();
                const minutes = Math.floor(finalTime / 60);
                const seconds = finalTime % 60;
              
                status.textContent = `ðŸŽ‰ Solved in ${minutes}:${seconds.toString().padStart(2, '0')}!`;
                status.className = 'status win';
              
                timer.classList.add('completed');
                stopTimer();
              
            } else {
                status.textContent = 'Keep going! Delete numbers to match the targets.';
                status.className = 'status';
                timer.classList.remove('completed');
            }
        }

        function resetPuzzle() {
            stopTimer();
            gameState.deleted = Array(7).fill().map(() => Array(7).fill(false));
            gameState.confirmed = Array(7).fill().map(() => Array(7).fill(false));
            gameState.startTime = null;
            gameState.gameCompleted = false;
          
            document.getElementById('gameTimer').textContent = '00:00';
            document.getElementById('gameTimer').classList.remove('completed');
          
            renderGrid();
            updateStatus();
        }

        function newPuzzle() {
            console.log("Generating new puzzle...");
            stopTimer();
            
            // Generate a new puzzle
            const generator = new SumpleteGenerator();
            const newPuzzle = generator.generate();
            
            // Reset game state
            gameState.startTime = null;
            gameState.gameCompleted = false;
            gameState.currentPuzzle = newPuzzle;
            
            document.getElementById('gameTimer').textContent = '00:00';
            document.getElementById('gameTimer').classList.remove('completed');
            
            // Initialize with the new puzzle
            initializeGame(newPuzzle);
        }

        // Initialize the game when the page loads
        console.log("Initializing game...");
        initializeGame();
    </script>
</body>
</html>